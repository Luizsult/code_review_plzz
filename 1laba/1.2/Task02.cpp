//Черепашка.На квадратной доске расставлены целые неотрицательные числа, каждое из которых не превосходит 100. 
//Черепашка, находящаяся в левом нижнем углу, мечтает попасть в правый верхний.
//При этом она может переползать только в клетку справа или сверху и хочет, 
//чтобы сумма всех чисел, оказавшихся у нее на пути, была бы минимальной.Определить
//эту сумму.Ввод и вывод организовать при помощи текстовых файлов.Формат входных данных :
//в первой строке входного файла записано число N - размер доски(1 < N < 80).Далее следует N
//строк, каждая из которых содержит N целых чисел, представляющих доску.В выходной файл
//нужно вывести единственное число : минимальную сумму.

#include <iostream>
#include <fstream>
#include <vector>
#include <iomanip>  

using namespace std;

int main() {
    setlocale(LC_ALL, "Russian"); 
    // Открытие файлов
    ifstream fin("input.txt");     // Файл с входными данными
    ofstream fout("output.txt");    // Файл для результата

    // Проверка успешности открытия файлов
    if (!fin.is_open()) {
        cerr << "Ошибка! Не удалось открыть input.txt\n";
        return 1;
    }
    if (!fout.is_open()) {
        cerr << "Ошибка! Не удалось создать output.txt\n";
        return 1;
    }

    // Чтение размера доски
    int n;
    fin >> n;

    // Проверка корректности размера доски
    if (n <= 1 || n >= 80) {
        cerr << "Некорректный размер доски! Допустимый диапазон: 1 < N < 80\n";
        return 1;
    }

    // Инициализация доски и списка ошибок
    vector<vector<int>> board(n, vector<int>(n));  // Доска NxN
    vector<pair<int, int>> errors;                 // Позиции с ошибками

    // Чтение данных из файла и проверка значений
    for (int i = 0; i < n; ++i) {
        for (int j = 0; j < n; ++j) {
            fin >> board[i][j];
            // Проверка, что число в диапазоне [0, 100]
            if (board[i][j] < 0 || board[i][j] > 100) {
                errors.push_back(make_pair(i, j));  // Запоминаем позицию ошибки
            }
        }
    }

    // Если есть ошибки - выводим их
    if (!errors.empty()) {
        cerr << "\nОШИБКИ В ДОСКЕ:\n";
        cout << "Входная доска (" << n << "x" << n << "):\n";

        // Вывод заголовка (номера столбцов)
        cout << "     ";
        for (int j = 0; j < n; ++j) cout << setw(6) << j;
        cout << "\n    +" << string(n * 6, '-') << "\n";  // Разделитель

        // Вывод строк доски с подсветкой ошибок
        for (int i = 0; i < n; ++i) {
            cout << setw(2) << i << " |";  // Номер строки
            for (int j = 0; j < n; ++j) {
                bool is_error = false;
                // Проверяем, есть ли текущая позиция в списке ошибок
                for (const auto& error : errors) {
                    if (error.first == i && error.second == j) {
                        is_error = true;
                        break;
                    }
                }
                // Выделяем ошибку символами '!'
                if (is_error) {
                    cout << " !" << setw(3) << board[i][j] << "!";
                }
                else {
                    cout << setw(6) << board[i][j];
                }
            }
            cout << "\n";
        }

        // Вывод списка ошибок
        cerr << "\nНекорректные значения:\n";
        for (const auto& error : errors) {
            cerr << "  Позиция (" << error.first << "," << error.second
                << "): " << board[error.first][error.second] << "\n";
        }
        return 1;  // Завершаем программу с ошибкой
    }

    // Вывод корректной доски
    cout << "Входная доска (" << n << "x" << n << "):\n";
    cout << "     ";
    for (int j = 0; j < n; ++j) cout << setw(4) << j;  // Номера столбцов
    cout << "\n    +" << string(n * 4, '-') << "\n";    // Разделитель

    for (int i = 0; i < n; ++i) {
        cout << setw(2) << i << " |";  // Номер строки
        for (int j = 0; j < n; ++j) {
            cout << setw(4) << board[i][j];  // Значение клетки
        }
        cout << "\n";
    }
    cout << endl;

    // Динамическое программирование для поиска минимального пути
    vector<vector<int>> dp(n, vector<int>(n));  // Таблица DP

    //Создание стартовой точки (левый нижний угол)
    dp[n - 1][0] = board[n - 1][0];

    // Заполнение нижней строки (движение только вправо)
    for (int j = 1; j < n; ++j) {
        dp[n - 1][j] = dp[n - 1][j - 1] + board[n - 1][j];
    }

    // Заполнение левого столбца (движение только вверх)
    for (int i = n - 2; i >= 0; --i) {
        dp[i][0] = dp[i + 1][0] + board[i][0];
    }

    // Заполнение остальных клеток (выбор минимального пути)
    for (int i = n - 2; i >= 0; --i) {
        for (int j = 1; j < n; ++j) {
            // Минимум из нижней и левой клетки + текущее значение
            dp[i][j] = min(dp[i + 1][j], dp[i][j - 1]) + board[i][j];
        }
    }

    // Запись результата в файл и вывод на консоль
    int result = dp[0][n - 1];  // Правый верхний угол
    fout << result;
    cout << "Минимальная сумма пути: " << result << endl;

    return 0;
}